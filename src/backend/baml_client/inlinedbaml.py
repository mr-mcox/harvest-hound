# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "client<llm> Anthropic {\n  provider anthropic\n  options {\n    model \"claude-sonnet-4-5\"\n    api_key env.ANTHROPIC_HH_API_KEY\n    max_tokens 1024\n  }\n}\n\nclient<llm> OpenAI {\n  provider openai\n  options {\n    model \"gpt-4o\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n",
    "generators.baml": "generator target {\n    output_type \"python/pydantic\"\n    output_dir \"../\"\n    version \"0.214.0\"\n    default_client_mode async\n}\n",
    "inventory.baml": "class Ingredient {\n    name string\n    quantity float\n    unit string\n    priority string\n    portion_size string?\n\n    @@assert(positive_quantity, {{ this.quantity > 0 }})\n    @@assert(name_not_empty, {{ this.name|length > 0 }})\n    @@assert(unit_not_empty, {{ this.unit|length > 0 }})\n}\n\nclass InventoryParsingResult {\n    ingredients Ingredient[]\n    parsing_notes string?\n}\n\nfunction ExtractIngredients(text: string, configuration_instructions: string?) -> InventoryParsingResult {\n    client OpenAI\n    prompt #\"\n        Extract ingredients from this text for a grocery/food inventory system.\n\n        <text>\n        {{ text }}\n        </text>\n\n        {% if configuration_instructions %}\n        <configuration_instructions>\n        {{ configuration_instructions }}\n        </configuration_instructions>\n\n        Apply these configuration instructions when parsing the ingredients. They may specify portion sizes, priorities, or other context about the batch.\n        {% endif %}\n\n        Extract ONLY ingredients that appear in the text above. Do not add any ingredients that are not explicitly mentioned.\n\n        Normalize ingredients with these guidelines:\n        - name: singular, lowercase, include category context when nested (e.g., \"pork butt roast\" not just \"butt roast\")\n        - quantity: numeric value (e.g., 2 not \"two\")\n        - unit: full name, singular, lowercase (e.g., \"pound\" not \"lbs\", \"cup\" not \"cups\")\n          - For countable items, use item-specific units: \"roast\", \"chop\", \"can\", \"jar\", \"head\", \"bunch\"\n          - When you see \"xN\" notation (e.g., \"x3\"), N is the quantity and the item type is the unit\n          - Avoid generic units like \"piece\", \"each\", \"item\" - be specific to what it is\n        - priority: infer based on perishability (how quickly it will spoil)\n          - \"urgent\": fresh items that spoil quickly (leafy greens, herbs, berries, fresh cream)\n          - \"high\": items to use relatively soon (other fresh vegetables, fresh meat)\n          - \"medium\": default for most items (root vegetables, frozen meat, pantry staples)\n          - \"low\": long shelf life (dried goods, canned items, frozen vegetables)\n        - portion_size: extract if specified in text or configuration instructions\n          - From text: \"3 16oz cans\" â†’ \"16 ounce\"\n          - From config: if config says \"all in 1 pound portions\", apply to relevant items\n          - Use full unit names (e.g., \"16 ounce\" not \"16oz\", \"1 pound\" not \"1lb\")\n          - Text-specified portions take precedence over config-specified portions\n          - null if no portion size specified anywhere\n          - The name should NOT include the container type (e.g., \"black bean\" not \"black bean can\")\n\n        {{ ctx.output_format }}\n    \"#\n}\n\ntest simple_units_carrots {\n    functions [ExtractIngredients]\n    args {\n        text \"2 lbs carrots\"\n        configuration_instructions null\n    }\n    @@assert({{ this.ingredients|length == 1 }})\n    @@assert({{ this.ingredients[0].name == \"carrot\" }})\n    @@assert({{ this.ingredients[0].quantity == 2 }})\n    @@assert({{ this.ingredients[0].unit == \"pound\" }})\n}\n\ntest simple_units_kale_bunch {\n    functions [ExtractIngredients]\n    args {\n        text \"1 bunch kale\"\n        configuration_instructions null\n    }\n    @@assert({{ this.ingredients|length == 1 }})\n    @@assert({{ this.ingredients[0].name == \"kale\" }})\n    @@assert({{ this.ingredients[0].quantity == 1 }})\n    @@assert({{ this.ingredients[0].unit == \"bunch\" }})\n}\n\ntest simple_units_multi_line {\n    functions [ExtractIngredients]\n    args {\n        text #\"\n        2 lbs carrots\n        1 bunch kale\n        1/2 cup rice\n        \"#\n        configuration_instructions null\n    }\n    @@assert({{ this.ingredients|length == 3 }})\n    @@assert({{ this.ingredients[0].name == \"carrot\" }})\n    @@assert({{ this.ingredients[1].name == \"kale\" }})\n    @@assert({{ this.ingredients[2].name == \"rice\" }})\n    @@assert({{ this.ingredients[2].quantity == 0.5 }})\n    @@assert({{ this.ingredients[2].unit == \"cup\" }})\n}\n\ntest count_units_meat_x_notation {\n    functions [ExtractIngredients]\n    args {\n        text #\"\n        - Pork\n            - Butt Roast x3\n            - Loin chops x4\n        \"#\n        configuration_instructions null\n    }\n    @@assert({{ this.ingredients|length == 2 }})\n    @@assert({{ this.ingredients[0].name == \"pork butt roast\" }})\n    @@assert({{ this.ingredients[0].quantity == 3 }})\n    @@assert({{ this.ingredients[0].unit == \"roast\" }})\n    @@assert({{ this.ingredients[1].name == \"pork loin chop\" }})\n    @@assert({{ this.ingredients[1].quantity == 4 }})\n    @@assert({{ this.ingredients[1].unit == \"chop\" }})\n}\n\ntest priority_inference_perishability {\n    functions [ExtractIngredients]\n    args {\n        text #\"\n        1 bunch spinach\n        2 lbs carrots\n        1 can black beans\n        1 lb fresh chicken breast\n        \"#\n        configuration_instructions null\n    }\n    @@assert({{ this.ingredients|length == 4 }})\n    // spinach is leafy green -> urgent\n    @@assert({{ this.ingredients[0].priority == \"urgent\" }})\n    // carrots are root vegetables -> medium or high\n    @@assert({{ this.ingredients[1].priority in [\"medium\", \"high\"] }})\n    // canned beans -> low\n    @@assert({{ this.ingredients[2].priority == \"low\" }})\n    // fresh chicken -> high\n    @@assert({{ this.ingredients[3].priority == \"high\" }})\n}\n\ntest portion_size_from_text {\n    functions [ExtractIngredients]\n    args {\n        text #\"\n        3 16oz cans black beans\n        4 1lb bags frozen peas\n        \"#\n        configuration_instructions null\n    }\n    @@assert({{ this.ingredients|length == 2 }})\n    // 3 cans, each 16oz\n    @@assert({{ this.ingredients[0].name == \"black bean\" }})\n    @@assert({{ this.ingredients[0].quantity == 3 }})\n    @@assert({{ this.ingredients[0].unit == \"can\" }})\n    @@assert({{ this.ingredients[0].portion_size == \"16 ounce\" }})\n    // 4 bags, each 1lb\n    @@assert({{ this.ingredients[1].name == \"frozen pea\" }})\n    @@assert({{ this.ingredients[1].quantity == 4 }})\n    @@assert({{ this.ingredients[1].unit == \"bag\" }})\n    @@assert({{ this.ingredients[1].portion_size == \"1 pound\" }})\n}\n\ntest portion_size_from_config {\n    functions [ExtractIngredients]\n    args {\n        text #\"\n        Ground beef x5\n        Chicken breast x3\n        \"#\n        configuration_instructions \"All meat is frozen in 1 pound portions\"\n    }\n    @@assert({{ this.ingredients|length == 2 }})\n    // Config says 1 pound portions for all meat\n    @@assert({{ this.ingredients[0].name == \"ground beef\" }})\n    @@assert({{ this.ingredients[0].quantity == 5 }})\n    @@assert({{ this.ingredients[0].portion_size == \"1 pound\" }})\n    @@assert({{ this.ingredients[1].name == \"chicken breast\" }})\n    @@assert({{ this.ingredients[1].quantity == 3 }})\n    @@assert({{ this.ingredients[1].portion_size == \"1 pound\" }})\n}\n",
}

def get_baml_files():
    return _file_map