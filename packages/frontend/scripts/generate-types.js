#!/usr/bin/env node
/**
 * Generate TypeScript types from backend Pydantic models.
 * This ensures frontend types are always in sync with backend.
 */

import { compileFromFile } from 'json-schema-to-typescript';
import { writeFileSync, mkdirSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

async function generateTypes() {
	try {
		// Path to the schema generated by backend
		const schemaPath = join(__dirname, '../../backend/generated/api-types.json');

		// Read the combined schema
		const { readFileSync } = await import('fs');
		const schemaData = JSON.parse(readFileSync(schemaPath, 'utf-8'));

		// Ensure output directory exists
		const outputDir = join(__dirname, '../src/lib/generated');
		mkdirSync(outputDir, { recursive: true });

		const bannerComment = [
			'/**',
			' * AUTO-GENERATED TypeScript types from backend Pydantic models.',
			' * DO NOT EDIT THIS FILE MANUALLY!',
			' * ',
			' * To update types:',
			' * 1. Update Pydantic models in packages/backend/app/models/',
			' * 2. Run: cd packages/backend && uv run python scripts/export_schemas.py',
			' * 3. Run: cd packages/frontend && npm run generate-types',
			' */'
		].join('\n');

		// Generate types for each definition
		const typeDefinitions = [];

		if (schemaData.definitions) {
			for (const [name, schema] of Object.entries(schemaData.definitions)) {
				// Create a temporary schema file for this type
				const tempSchema = {
					$schema: 'http://json-schema.org/draft-07/schema#',
					title: name,
					...schema,
					definitions: schemaData.definitions // Include all definitions for reference resolution
				};

				// Write temp schema to compile
				const tempPath = join(outputDir, `temp-${name}.json`);
				writeFileSync(tempPath, JSON.stringify(tempSchema, null, 2));

				try {
					const typescript = await compileFromFile(tempPath, {
						bannerComment: false,
						style: {
							printWidth: 100,
							tabWidth: 2,
							useTabs: false
						},
						declareExternallyReferenced: false,
						additionalProperties: false,
						enableConstEnums: false,
						format: false,
						strictIndexSignatures: false,
						unreachableDefinitions: false,
						unknownAny: false
					});

					// Extract the interface (remove any export default)
					let cleanTypescript = typescript
						.replace(/export default[^;]*;?\s*$/gm, '')
						.replace(/export\s+interface\s+(\w+)/g, 'export interface $1')
						.trim();

					// Add ESLint disable for WebSocketMessage data field's any type
					if (name === 'WebSocketMessage' && cleanTypescript.includes('[k: string]: any')) {
						cleanTypescript = cleanTypescript.replace(
							/(\[k: string\]: any)/g,
							'// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t$1'
						);
					}

					if (cleanTypescript) {
						typeDefinitions.push(cleanTypescript);
					}
				} catch (compileError) {
					console.warn(`‚ö†Ô∏è  Failed to compile ${name}:`, compileError.message);
				}

				// Clean up temp file
				try {
					const { unlinkSync } = await import('fs');
					unlinkSync(tempPath);
				} catch {
					// Ignore cleanup errors - temp file may not exist
				}
			}
		}

		// Combine all type definitions with banner
		const finalTypescript = [bannerComment, '', typeDefinitions.join('\n\n'), ''].join('\n');

		// Write TypeScript file
		const outputPath = join(outputDir, 'api-types.ts');
		writeFileSync(outputPath, finalTypescript);

		console.log('‚úÖ Generated TypeScript types from backend schemas');
		console.log(`üìÅ Output: ${outputPath}`);
		console.log(`üìä Generated ${typeDefinitions.length} type definitions`);
		console.log('üîó Frontend types are now synchronized with backend Pydantic models');
	} catch (error) {
		console.error('‚ùå Failed to generate types:', error.message);
		process.exit(1);
	}
}

generateTypes();
